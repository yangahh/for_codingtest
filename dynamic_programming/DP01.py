# 문제) 개미 전사의 식량창고 털기
# 정해진 수의 식량을 저장하고 있으며 일직선으로 이어진 식량창고를 선택적으로 약탈하여 식량을 뺏을 예정. 인접한 식량창고는 털 수 없다

'''
# 문제 해결 방안
 i번째 식량창고를 털지 안 털지 여부를 결정할 떄 (i - 1)번째 창고의 식량과 (i - 2)번째 창고의 식량 + i번째 식량 중 큰 값 
 - (i - 1)번째 식량 창고를 털기로 결정한 경우 현재 식량창고(=i)를 털 수 없다.
 - (i - 2)번째 식량 창고를 털기로 결정한 경우 현재 식량창고(=i)를 털 수 있다.
 - (i - 3)번째 이하의 식량창고에 대해서는 무조건 털 수 있으므로 고려할 필요가 없음.

즉 점화식으로 표현하면 ai = max(a(i-1), a(i-2) + k). ** k는 i번째 식량창고에 있는 식량의 크기
'''

n = int(input())
array = list(map(int, input().split()))

'''
# DP테이블 초기화 (n의 범위가 최대 100이여서 100까지)
d = [0] * 100

# 보텀업 방식의 DP
d[0] = array[0]
d[1] = max(array[0], array[1])

for i in range(2, n):
    d[i] = max(d[i-1], d[i-2] + array[i])

print(d[n - 1])

'''
# 탑다운 형식
dp = [0] * 100

def topdown(x):
    # 종료조건
    if x == 0:
        return array[0]
    if x == 1:
        return max(array[0], array[1])

    # 이미 계산 된 문제라면 그대로 함수 호출
    if dp[x] != 0:
        return dp[x]
    
    # 아직 계산되지 않은 문제라면 점화식에 따라 결과 반환
    dp[x] = max(d[x - 1], d[x - 2] + array[x])
    return dp[x]


print(topdown(n))
